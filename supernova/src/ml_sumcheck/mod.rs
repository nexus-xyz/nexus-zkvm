//! Sumcheck Protocol for multilinear extension

// This implementation is pulled from `ark-linear-sumcheck` and adapted to use cryptographic
// sponge interface instead of blake2 -- [https://github.com/arkworks-rs/sumcheck]

#![forbid(unsafe_code)]
#![allow(unused)]

use ark_crypto_primitives::sponge::{Absorb, CryptographicSponge};
use ark_ff::PrimeField;
use ark_std::marker::PhantomData;

mod data_structures;
mod protocol;

#[cfg(test)]
mod tests;

pub use data_structures::{ListOfProductsOfPolynomials, PolynomialInfo};
use protocol::{
    prover::{ProverMsg, ProverState},
    verifier::SubClaim,
    IPForMLSumcheck,
};

#[derive(Debug)]
pub enum Error {
    /// protocol rejects this proof
    Reject,
}

/// Sumcheck for products of multilinear polynomial
pub struct MLSumcheck<F, RO>(#[doc(hidden)] PhantomData<(F, RO)>);

/// proof generated by prover
pub type Proof<F> = Vec<ProverMsg<F>>;

impl<F: PrimeField + Absorb, RO: CryptographicSponge> MLSumcheck<F, RO> {
    /// extract sum from the proof
    pub fn extract_sum(proof: &Proof<F>) -> F {
        proof[0].evaluations[0] + proof[0].evaluations[1]
    }

    /// generate proof of the sum of polynomial over {0,1}^`num_vars`
    ///
    /// The polynomial is represented by a list of products of polynomials along with its coefficient that is meant to be added together.
    ///
    /// This data structure of the polynomial is a list of list of `(coefficient, DenseMultilinearExtension)`.
    /// * Number of products n = `polynomial.products.len()`,
    /// * Number of multiplicands of ith product m_i = `polynomial.products[i].1.len()`,
    /// * Coefficient of ith product c_i = `polynomial.products[i].0`
    ///
    /// The resulting polynomial is
    ///
    /// $$\sum_{i=0}^{n}C_i\cdot\prod_{j=0}^{m_i}P_{ij}$$
    pub fn prove(config: &RO::Config, polynomial: &ListOfProductsOfPolynomials<F>) -> Proof<F> {
        let mut random_oracle = RO::new(config);
        Self::prove_as_subprotocol(&mut random_oracle, polynomial).0
    }

    /// This function does the same thing as `prove`, but it uses cryptographic sponge as the transcript/to generate the
    /// verifier challenges. Additionally, it returns the prover's state in addition to the proof.
    /// Both of these allow this sumcheck to be better used as a part of a larger protocol.
    pub fn prove_as_subprotocol(
        random_oracle: &mut RO,
        polynomial: &ListOfProductsOfPolynomials<F>,
    ) -> (Proof<F>, ProverState<F>) {
        random_oracle.absorb(&polynomial.info());

        let mut prover_state = IPForMLSumcheck::<F, RO>::prover_init(polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.num_variables);
        for _ in 0..polynomial.num_variables {
            let prover_msg =
                IPForMLSumcheck::<F, RO>::prove_round(&mut prover_state, &verifier_msg);
            random_oracle.absorb(&prover_msg);
            prover_msgs.push(prover_msg);
            let next_verifier_msg = IPForMLSumcheck::<F, RO>::sample_round(random_oracle);
            random_oracle.absorb(&next_verifier_msg.randomness);

            verifier_msg = Some(next_verifier_msg);
        }

        (prover_msgs, prover_state)
    }

    /// verify the claimed sum using the proof
    pub fn verify(
        config: &RO::Config,
        polynomial_info: &PolynomialInfo,
        claimed_sum: F,
        proof: &Proof<F>,
    ) -> Result<SubClaim<F>, Error> {
        let mut random_oracle = RO::new(config);
        Self::verify_as_subprotocol(&mut random_oracle, polynomial_info, claimed_sum, proof)
    }

    /// This function does the same thing as `prove`, but it uses a cryptographic sponge as the transcript/to generate the
    /// verifier challenges. This allows this sumcheck to be used as a part of a larger protocol.
    pub fn verify_as_subprotocol(
        random_oracle: &mut RO,
        polynomial_info: &PolynomialInfo,
        claimed_sum: F,
        proof: &Proof<F>,
    ) -> Result<SubClaim<F>, Error> {
        random_oracle.absorb(polynomial_info);

        let mut verifier_state = IPForMLSumcheck::<F, RO>::verifier_init(polynomial_info);
        for i in 0..polynomial_info.num_variables {
            let prover_msg = proof.get(i).expect("proof is incomplete");
            random_oracle.absorb(prover_msg);
            let verifier_msg = IPForMLSumcheck::verify_round(
                (*prover_msg).clone(),
                &mut verifier_state,
                random_oracle,
            );
            random_oracle.absorb(&verifier_msg.randomness);
        }

        IPForMLSumcheck::<F, RO>::check_and_generate_subclaim(verifier_state, claimed_sum)
    }
}
