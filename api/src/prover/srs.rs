use std::fs::File;
use zstd::stream::Decoder;

use crate::prover::{
    error::ProofError,
    pp::gen_vm_pp,
    types::{ParPP, SpartanKey, SRS},
};

pub use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};

pub fn load_srs(file: &str) -> Result<SRS, ProofError> {
    let f = File::open(file)?;
    let mut dec = Decoder::new(&f)?;
    // we can use `deserialize_compressed` instead of `deserialize_compressed_unchecked` here since
    // the expensive operation of checking that group elements are in the correct subgroup
    // has been disabled for prime-order curve groups in https://github.com/arkworks-rs/algebra/pull/771.
    let srs = SRS::deserialize_compressed(&mut dec)?;
    Ok(srs)
}

/// Derive the minimum (log) size of the SRS to support compression for a
/// given `k`.
pub fn get_min_srs_size(k: usize) -> Result<usize, ProofError> {
    // these are only used to get the size of the r1cs matrices for a given k.
    let dummy_pp: ParPP = gen_vm_pp(k, &())?;
    let ParPP { shape, .. } = dummy_pp;

    Ok(SpartanKey::get_min_srs_size(&shape))
}

pub mod test_srs {
    use super::*;
    use ark_std::test_rng;
    use zstd::stream::Encoder;

    use crate::prover::types::{PolyCommitmentScheme, PC};
    /// This function should only be used for testing, as it is insescure:
    /// the SRS should be generated by a trusted setup ceremony.
    pub fn gen_test_srs(num_vars: usize) -> Result<SRS, ProofError> {
        let mut rng = test_rng();
        PC::setup(num_vars, b"test_srs", &mut rng).map_err(|_| ProofError::SRSSamplingError)
    }

    pub fn save_srs(srs: SRS, file: &str) -> Result<(), ProofError> {
        let f = File::create(file)?;
        let mut enc = Encoder::new(&f, 0)?;
        srs.serialize_compressed(&mut enc)?;
        enc.finish()?;
        f.sync_all()?;
        Ok(())
    }

    pub fn gen_test_srs_to_file(poly_length: usize, file: &str) -> Result<(), ProofError> {
        let srs = gen_test_srs(poly_length)?;
        save_srs(srs, file)
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn min_srs_size_k1() {
        let k = 1;
        println!(
            "min srs size for k = 1: {}",
            super::get_min_srs_size(k).unwrap()
        );
    }
}
